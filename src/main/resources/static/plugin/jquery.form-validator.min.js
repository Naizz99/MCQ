/*!
 * jQuery Validation Plugin v1.19.1
 *
 * https://jqueryvalidation.org/
 *
 * Copyright (c) 2019 JÃ¶rn Zaefferer
 * Released under the MIT license
 */

!function (a, b) { "function" == typeof define && define.amd ? define(["jquery"], function (a) { return b(a) }) : "object" == typeof module && module.exports ? module.exports = b(require("jquery")) : b(a.jQuery) }(this, function (a) {
!function (a, b, c) { function d(a, b) { this.$form = a, this.$input = b, this.reset(), b.on("change paste", this.reset.bind(this)) } var e = function () { return !1 }, f = null, g = { numHalted: 0, haltValidation: function (b) { this.numHalted++ , a.formUtils.haltValidation = !0, b.unbind("submit", e).bind("submit", e).find('*[type="submit"]').addClass("disabled").attr("disabled", "disabled") }, unHaltValidation: function (b) { this.numHalted-- , 0 === this.numHalted && (a.formUtils.haltValidation = !1, b.unbind("submit", e).find('*[type="submit"]').removeClass("disabled").removeAttr("disabled", "disabled")) } }; d.prototype.reset = function () { this.haltedFormValidation = !1, this.hasRun = !1, this.isRunning = !1, this.result = c }, d.prototype.run = function (a, b) { return "keyup" === a ? null : this.isRunning ? (f = a, this.haltedFormValidation || (g.haltValidation(), this.haltedFormValidation = !0), null) : this.hasRun ? this.result : (f = a, g.haltValidation(this.$form), this.haltedFormValidation = !0, this.isRunning = !0, this.$input.attr("disabled", "disabled").addClass("async-validation"), this.$form.addClass("async-validation"), b(function (a) { this.done(a) }.bind(this)), null) }, d.prototype.done = function (a) { this.result = a, this.hasRun = !0, this.isRunning = !1, this.$input.removeAttr("disabled").removeClass("async-validation"), this.$form.removeClass("async-validation"), this.haltedFormValidation && (g.unHaltValidation(this.$form), "submit" === f ? this.$form.trigger("submit") : this.$input.trigger("validation.revalidate")) }, d.loadInstance = function (a, b, c) { var e, f = b.get(0); return f.asyncValidators || (f.asyncValidators = {}), f.asyncValidators[a] ? e = f.asyncValidators[a] : (e = new d(c, b), f.asyncValidators[a] = e), e }, a.formUtils = a.extend(a.formUtils || {}, { asyncValidation: function (a, b, c) { return this.warn("Use of deprecated function $.formUtils.asyncValidation, use $.formUtils.addAsyncValidator() instead"), d.loadInstance(a, b, c) }, addAsyncValidator: function (b) { var c = a.extend({}, b), e = c.validatorFunction; c.async = !0, c.validatorFunction = function (a, b, f, g, h, i) { var j = d.loadInstance(this.name, b, h); return j.run(i, function (d) { e.apply(c, [d, a, b, f, g, h, i]) }) }, this.addValidator(c) } }), a(b).bind("validatorsLoaded formValidationSetup", function (b, c) { c || (c = a("form")), c.find("[data-validation]").each(function () { var b = a(this); b.valAttr("async", !1), a.each(a.split(b.attr("data-validation")), function (c, d) { var e = a.formUtils.validators["validate_" + d]; e && e.async && b.valAttr("async", "yes") }) }) }) }(a, window), function (a, b) { "use strict"; function c(b) { b && "custom" === b.errorMessagePosition && "function" == typeof b.errorMessageCustom && (a.formUtils.warn("Use of deprecated function errorMessageCustom, use config.submitErrorMessageCallback instead"), b.submitErrorMessageCallback = function (a, c) { b.errorMessageCustom(a, b.language.errorTitle, c, b) }) } function d(b) { if (b.errorMessagePosition && "object" == typeof b.errorMessagePosition) { a.formUtils.warn("Deprecated use of config parameter errorMessagePosition, use config.submitErrorMessageCallback instead"); var c = b.errorMessagePosition; b.errorMessagePosition = "top", b.submitErrorMessageCallback = function () { return c } } } function e(b) { var c = b.find("[data-validation-if-checked]"); c.length && a.formUtils.warn('Detected use of attribute "data-validation-if-checked" which is deprecated. Use "data-validation-depends-on" provided by module "logic"'), c.on("beforeValidation", function () { var c = a(this), d = c.valAttr("if-checked"), e = a('input[name="' + d + '"]', b), f = e.is(":checked"), g = (a.formUtils.getValue(e) || "").toString(), h = c.valAttr("if-checked-value"); (!f || h && h !== g) && c.valAttr("skipped", !0) }) } function f(b) { var c = { se: "sv", cz: "cs", dk: "da" }; if (b.lang in c) { var d = c[b.lang]; a.formUtils.warn('Deprecated use of lang code "' + b.lang + '" use "' + d + '" instead'), b.lang = d } } a.fn.validateForm = function (b, c) { return a.formUtils.warn("Use of deprecated function $.validateForm, use $.isValid instead"), this.isValid(b, c, !0) }, a(window).on("formValidationPluginInit", function (a, b) { f(b), c(b), d(b) }).on("validatorsLoaded formValidationSetup", function (b, c) { c || (c = a("form")), e(c) }) }(a), function (a) { "use strict"; var b = { resolveErrorMessage: function (a, b, c, d, e) { var f = d.validationErrorMsgAttribute + "-" + c.replace("validate_", ""), g = a.attr(f); return g || (g = a.attr(d.validationErrorMsgAttribute), g || (g = "function" != typeof b.errorMessageKey ? e[b.errorMessageKey] : e[b.errorMessageKey(d)], g || (g = b.errorMessage))), g }, getParentContainer: function (b) { if (b.valAttr("error-msg-container")) return a(b.valAttr("error-msg-container")); var c = b.parent(); return "checkbox" === b.attr("type") && b.closest(".checkbox").length ? c = b.closest(".checkbox").parent() : "radio" === b.attr("type") && b.closest(".radio").length && (c = b.closest(".radio").parent()), c.closest(".input-group").length && (c = c.closest(".input-group").parent()), c }, applyInputErrorStyling: function (a, b) { a.addClass(b.errorElementClass).removeClass(b.successElementClass), this.getParentContainer(a).addClass(b.inputParentClassOnError).removeClass(b.inputParentClassOnSuccess), "" !== b.borderColorOnError && a.css("border-color", b.borderColorOnError) }, applyInputSuccessStyling: function (a, b) { a.addClass(b.successElementClass), this.getParentContainer(a).addClass(b.inputParentClassOnSuccess) }, removeInputStylingAndMessage: function (a, c) { a.removeClass(c.successElementClass).removeClass(c.errorElementClass).css("border-color", ""); var d = b.getParentContainer(a); if (d.removeClass(c.inputParentClassOnError).removeClass(c.inputParentClassOnSuccess), "function" == typeof c.inlineErrorMessageCallback) { var e = c.inlineErrorMessageCallback(a, !1, c); e && e.html("") } else d.find("." + c.errorMessageClass).remove() }, removeAllMessagesAndStyling: function (c, d) { if ("function" == typeof d.submitErrorMessageCallback) { var e = d.submitErrorMessageCallback(c, !1, d); e && e.html("") } else c.find("." + d.errorMessageClass + ".alert").remove(); c.find("." + d.errorElementClass + ",." + d.successElementClass).each(function () { b.removeInputStylingAndMessage(a(this), d) }) }, setInlineMessage: function (b, c, d) { this.applyInputErrorStyling(b, d); var e, f = document.getElementById(b.attr("name") + "_err_msg"), g = !1, h = function (d) { a.formUtils.$win.trigger("validationErrorDisplay", [b, d]), d.html(c) }, i = function () { var f = !1; g.find("." + d.errorMessageClass).each(function () { if (this.inputReferer === b[0]) return f = a(this), !1 }), f ? c ? h(f) : f.remove() : "" !== c && (e = a('<div class="' + d.errorMessageClass + ' alert"></div>'), h(e), e[0].inputReferer = b[0], g.prepend(e)) }; if (f) a.formUtils.warn("Using deprecated element reference " + f.id), g = a(f), i(); else if ("function" == typeof d.inlineErrorMessageCallback) { if (g = d.inlineErrorMessageCallback(b, c, d), !g) return; i() } else { var j = this.getParentContainer(b); e = j.find("." + d.errorMessageClass + ".help-block"), 0 === e.length && (e = a("<span></span>").addClass("help-block").addClass(d.errorMessageClass), e.appendTo(j)), h(e) } }, setMessageInTopOfForm: function (b, c, d, e) { var f = '<div class="{errorMessageClass} alert alert-danger"><strong>{errorTitle}</strong><ul>{fields}</ul></div>', g = !1; if ("function" != typeof d.submitErrorMessageCallback || (g = d.submitErrorMessageCallback(b, c, d))) { var h = { errorTitle: e.errorTitle, fields: "", errorMessageClass: d.errorMessageClass }; a.each(c, function (a, b) { h.fields += "<li>" + b + "</li>" }), a.each(h, function (a, b) { f = f.replace("{" + a + "}", b) }), g ? g.html(f) : b.children().eq(0).before(a(f)) } } }; a.formUtils = a.extend(a.formUtils || {}, { dialogs: b }) }(a), function (a, b, c) { "use strict"; var d = 0; a.fn.validateOnBlur = function (b, c) { var d = this, e = this.find("*[data-validation]"); return e.each(function () { var e = a(this); if (e.is("[type=radio]")) { var f = d.find('[type=radio][name="' + e.attr("name") + '"]'); f.bind("blur.validation", function () { e.validateInputOnBlur(b, c, !0, "blur") }), c.validateCheckboxRadioOnClick && f.bind("click.validation", function () { e.validateInputOnBlur(b, c, !0, "click") }) } }), e.bind("blur.validation", function () { a(this).validateInputOnBlur(b, c, !0, "blur") }), c.validateCheckboxRadioOnClick && this.find("input[type=checkbox][data-validation],input[type=radio][data-validation]").bind("click.validation", function () { a(this).validateInputOnBlur(b, c, !0, "click") }), this }, a.fn.validateOnEvent = function (b, c) { if (0 !== this.length) { var d = "FORM" === this[0].nodeName ? this.find("*[data-validation-event]") : this; return d.each(function () { var d = a(this), e = d.valAttr("event"); e && d.unbind(e + ".validation").bind(e + ".validation", function (d) { 9 !== (d || {}).keyCode && a(this).validateInputOnBlur(b, c, !0, e) }) }), this } }, a.fn.showHelpOnFocus = function (b) { return b || (b = "data-validation-help"), this.find("textarea,input").each(function () { var c = a(this), e = "jquery_form_help_" + ++d, f = c.attr(b); c.removeClass("has-help-text").unbind("focus.help").unbind("blur.help"), f && c.addClass("has-help-txt").bind("focus.help", function () { var b = c.parent().find("." + e); 0 === b.length && (b = a("<span />").addClass(e).addClass("help").addClass("help-block").text(f).hide(), c.after(b)), b.fadeIn() }).bind("blur.help", function () { a(this).parent().find("." + e).fadeOut("slow") }) }), this }, a.fn.validate = function (b, c, d) { var e = a.extend({}, a.formUtils.LANG, d || {}); this.each(function () { var d = a(this), f = d.closest("form").get(0) || {}, g = f.validationConfig || a.formUtils.defaultConfig(); d.one("validation", function (a, c) { "function" == typeof b && b(c, this, a) }), d.validateInputOnBlur(e, a.extend({}, g, c || {}), !0) }) }, a.fn.willPostponeValidation = function () { return (this.valAttr("suggestion-nr") || this.valAttr("postpone") || this.hasClass("hasDatepicker")) && !b.postponedValidation }, a.fn.validateInputOnBlur = function (c, d, e, f) { if (a.formUtils.eventType = f, this.willPostponeValidation()) { var g = this, h = this.valAttr("postpone") || 200; return b.postponedValidation = function () { g.validateInputOnBlur(c, d, e, f), b.postponedValidation = !1 }, setTimeout(function () { b.postponedValidation && b.postponedValidation() }, h), this } c = a.extend({}, a.formUtils.LANG, c || {}), a.formUtils.dialogs.removeInputStylingAndMessage(this, d); var i = this, j = i.closest("form"), k = a.formUtils.validateInput(i, c, d, j, f), l = function () { i.validateInputOnBlur(c, d, !1, "blur.revalidated") }; return "blur" === f && i.unbind("validation.revalidate", l).one("validation.revalidate", l), e && i.removeKeyUpValidation(), k.shouldChangeDisplay && (k.isValid ? a.formUtils.dialogs.applyInputSuccessStyling(i, d) : a.formUtils.dialogs.setInlineMessage(i, k.errorMsg, d)), !k.isValid && e && i.validateOnKeyUp(c, d), this }, a.fn.validateOnKeyUp = function (b, c) { return this.each(function () { var d = a(this); d.valAttr("has-keyup-event") || d.valAttr("has-keyup-event", "true").bind("keyup.validation", function (a) { 9 !== a.keyCode && d.validateInputOnBlur(b, c, !1, "keyup") }) }), this }, a.fn.removeKeyUpValidation = function () { return this.each(function () { a(this).valAttr("has-keyup-event", !1).unbind("keyup.validation") }), this }, a.fn.valAttr = function (a, b) { return b === c ? this.attr("data-validation-" + a) : b === !1 || null === b ? this.removeAttr("data-validation-" + a) : (a = a.length > 0 ? "-" + a : "", this.attr("data-validation" + a, b)) }, a.fn.isValid = function (b, c, d) { if (a.formUtils.isLoadingModules) { var e = this; return setTimeout(function () { e.isValid(b, c, d) }, 200), null } c = a.extend({}, a.formUtils.defaultConfig(), c || {}), b = a.extend({}, a.formUtils.LANG, b || {}), d = d !== !1, a.formUtils.errorDisplayPreventedWhenHalted && (delete a.formUtils.errorDisplayPreventedWhenHalted, d = !1); var f = function (b, e) { a.inArray(b, h) < 0 && h.push(b), i.push(e), e.valAttr("current-error", b), d && a.formUtils.dialogs.applyInputErrorStyling(e, c) }, g = [], h = [], i = [], j = this, k = function (b, d) { return "submit" === d || "button" === d || "reset" === d || a.inArray(b, c.ignore || []) > -1 }; if (d && a.formUtils.dialogs.removeAllMessagesAndStyling(j, c), j.find("input,textarea,select").filter(':not([type="submit"],[type="button"])').each(function () { var d = a(this), e = d.attr("type"), h = "radio" === e || "checkbox" === e, i = d.attr("name"); if (!k(i, e) && (!h || a.inArray(i, g) < 0)) { h && g.push(i); var l = a.formUtils.validateInput(d, b, c, j, "submit"); l.isValid ? l.isValid && l.shouldChangeDisplay && (d.valAttr("current-error", !1), a.formUtils.dialogs.applyInputSuccessStyling(d, c)) : f(l.errorMsg, d) } }), "function" == typeof c.onValidate) { var l = c.onValidate(j); a.isArray(l) ? a.each(l, function (a, b) { f(b.message, b.element) }) : l && l.element && l.message && f(l.message, l.element) } return a.formUtils.isValidatingEntireForm = !1, i.length > 0 && d && ("top" === c.errorMessagePosition ? a.formUtils.dialogs.setMessageInTopOfForm(j, h, c, b) : a.each(i, function (b, d) { a.formUtils.dialogs.setInlineMessage(d, d.valAttr("current-error"), c) }), c.scrollToTopOnError && a.formUtils.$win.scrollTop(j.offset().top - 20)), !d && a.formUtils.haltValidation && (a.formUtils.errorDisplayPreventedWhenHalted = !0), 0 === i.length && !a.formUtils.haltValidation }, a.fn.restrictLength = function (b) { return new a.formUtils.lengthRestriction(this, b), this }, a.fn.addSuggestions = function (b) { var c = !1; return this.find("input").each(function () { var d = a(this); c = a.split(d.attr("data-suggestions")), c.length > 0 && !d.hasClass("has-suggestions") && (a.formUtils.suggest(d, c, b), d.addClass("has-suggestions")) }), this } }(a, window), function (a) { "use strict"; a.formUtils = a.extend(a.formUtils || {}, { isLoadingModules: !1, loadedModules: {}, registerLoadedModule: function (b) { this.loadedModules[a.trim(b).toLowerCase()] = !0 }, hasLoadedModule: function (b) { return a.trim(b).toLowerCase() in this.loadedModules }, loadModules: function (b, c, d) { if (a.formUtils.isLoadingModules) return void setTimeout(function () { a.formUtils.loadModules(b, c, d) }, 100); var e = function (b, c) { var e = a.split(b), f = e.length, g = function () { f-- , 0 === f && (a.formUtils.isLoadingModules = !1, "function" == typeof d && d()) }; f > 0 && (a.formUtils.isLoadingModules = !0); var h = "?_=" + (new Date).getTime(), i = document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]; a.each(e, function (b, d) { if (d = a.trim(d), 0 === d.length || a.formUtils.hasLoadedModule(d)) g(); else { var e = c + d + (".js" === d.slice(-3) ? "" : ".js"), f = document.createElement("SCRIPT"); "function" == typeof define && define.amd ? require([e + (".dev.js" === e.slice(-7) ? h : "")], g) : (f.type = "text/javascript", f.onload = g, f.src = e + (".dev.js" === e.slice(-7) ? h : ""), f.onerror = function () { a.formUtils.warn("Unable to load form validation module " + e, !0), g() }, f.onreadystatechange = function () { "complete" !== this.readyState && "loaded" !== this.readyState || (g(), this.onload = null, this.onreadystatechange = null) }, i.appendChild(f)) } }) }; if (c) e(b, c); else { var f = function () { var c = !1; return a('script[src*="form-validator"]').each(function () { var a = this.src.split("form-validator")[1].split("node_modules").length > 1; if (!a) return c = this.src.substr(0, this.src.lastIndexOf("/")) + "/", "/" === c && (c = ""), !1 }), c !== !1 && (e(b, c), !0) }; f() || a(function () { var a = f(); a || "function" == typeof d && d() }) } } }) }(a), function (a) { "use strict"; a.split = function (b, c, d) { d = void 0 === d || d === !0; var e = "[,|" + (d ? "\\s" : "") + "-]\\s*", f = new RegExp(e, "g"); if ("function" != typeof c) { if (!b) return []; var g = []; return a.each(b.split(c ? c : f), function (b, c) { c = a.trim(c), c.length && g.push(c) }), g } b && a.each(b.split(f), function (b, d) { if (d = a.trim(d), d.length) return c(d, b) }) }, a.validate = function (b) { var c = a.extend(a.formUtils.defaultConfig(), { form: "form", validateOnEvent: !1, validateOnBlur: !0, validateCheckboxRadioOnClick: !0, showHelpOnFocus: !0, addSuggestions: !0, modules: "", onModulesLoaded: null, language: !1, onSuccess: !1, onError: !1, onElementValidate: !1 }); if (b = a.extend(c, b || {}), a(window).trigger("formValidationPluginInit", [b]), b.lang && "en" !== b.lang) { var d = "lang/" + b.lang + ".js"; b.modules += b.modules.length ? "," + d : d } a(b.form).each(function (c, d) { d.validationConfig = b; var e = a(d); e.trigger("formValidationSetup", [e, b]), e.find(".has-help-txt").unbind("focus.validation").unbind("blur.validation"), e.removeClass("has-validation-callback").unbind("submit.validation").unbind("reset.validation").find("input[data-validation],textarea[data-validation]").unbind("blur.validation"), e.bind("submit.validation", function (c) { var d = a(this), e = function () { return c.stopImmediatePropagation(), !1 }; if (a.formUtils.haltValidation) return e(); if (a.formUtils.isLoadingModules) return setTimeout(function () { d.trigger("submit.validation") }, 200), e(); var f = d.isValid(b.language, b); if (a.formUtils.haltValidation) return e(); if (!f || "function" != typeof b.onSuccess) return f || "function" != typeof b.onError ? !!f || e() : (b.onError(d), e()); var g = b.onSuccess(d); return g === !1 ? e() : void 0 }).bind("reset.validation", function () { a.formUtils.dialogs.removeAllMessagesAndStyling(e, b) }).addClass("has-validation-callback"), b.showHelpOnFocus && e.showHelpOnFocus(), b.addSuggestions && e.addSuggestions(), b.validateOnBlur && (e.validateOnBlur(b.language, b), e.bind("html5ValidationAttrsFound", function () { e.validateOnBlur(b.language, b) })), b.validateOnEvent && e.validateOnEvent(b.language, b) }), "" !== b.modules && a.formUtils.loadModules(b.modules, null, function () { "function" == typeof b.onModulesLoaded && b.onModulesLoaded(); var c = "string" == typeof b.form ? a(b.form) : b.form; a.formUtils.$win.trigger("validatorsLoaded", [c, b]) }) } }(a), function (a, b) { "use strict"; var c = a(b); a.formUtils = a.extend(a.formUtils || {}, { $win: c, defaultConfig: function () { return { ignore: [], errorElementClass: "error", successElementClass: "valid", borderColorOnError: "#b94a48", errorMessageClass: "form-error", validationRuleAttribute: "data-validation", validationErrorMsgAttribute: "data-validation-error-msg", errorMessagePosition: "inline", errorMessageTemplate: { container: '<div class="{errorMessageClass} alert alert-danger">{messages}</div>', messages: "<strong>{errorTitle}</strong><ul>{fields}</ul>", field: "<li>{msg}</li>" }, scrollToTopOnError: !0, dateFormat: "yyyy-mm-dd", addValidClassOnAll: !1, decimalSeparator: ".", inputParentClassOnError: "has-error", inputParentClassOnSuccess: "has-success", validateHiddenInputs: !1, inlineErrorMessageCallback: !1, submitErrorMessageCallback: !1 } }, validators: {}, sanitizers: {}, _events: { load: [], valid: [], invalid: [] }, haltValidation: !1, addValidator: function (a) { var b = 0 === a.name.indexOf("validate_") ? a.name : "validate_" + a.name; void 0 === a.validateOnKeyUp && (a.validateOnKeyUp = !0), this.validators[b] = a }, addSanitizer: function (a) { this.sanitizers[a.name] = a }, warn: function (a, c) { "console" in b ? "function" == typeof b.console.warn ? b.console.warn(a) : "function" == typeof b.console.log && b.console.log(a) : c && alert(a) }, getValue: function (a, b) { var c = b ? b.find(a) : a; if (c.length > 0) { var d = c.eq(0).attr("type"); return "radio" === d || "checkbox" === d ? c.filter(":checked").val() || "" : c.val() || "" } return !1 }, validateInput: function (b, c, d, e, f) { d = d || a.formUtils.defaultConfig(), c = c || a.formUtils.LANG, e.length || (e = b.parent()); var g = this.getValue(b); b.valAttr("skipped", !1).one("beforeValidation", function () { (b.attr("disabled") || !b.is(":visible") && !d.validateHiddenInputs) && b.valAttr("skipped", 1) }).trigger("beforeValidation", [g, c, d]); var h = "true" === b.valAttr("optional"), i = !g && h, j = b.attr(d.validationRuleAttribute), k = !0, l = "", m = { isValid: !0, shouldChangeDisplay: !0, errorMsg: "" }; if (!j || i || b.valAttr("skipped")) return m.shouldChangeDisplay = d.addValidClassOnAll, m; var n = b.valAttr("ignore"); return n && a.each(n.split(""), function (a, b) { g = g.replace(new RegExp("\\" + b, "g"), "") }), a.split(j, function (h) { 0 !== h.indexOf("validate_") && (h = "validate_" + h); var i = a.formUtils.validators[h]; if (!i) throw new Error('Using undefined validator "' + h + '". Maybe you have forgotten to load the module that "' + h + '" belongs to?'); if ("validate_checkbox_group" === h && (b = e.find('[name="' + b.attr("name") + '"]:eq(0)')), ("keyup" !== f || i.validateOnKeyUp) && (k = i.validatorFunction(g, b, d, c, e, f)), !k) return d.validateOnBlur && b.validateOnKeyUp(c, d), l = a.formUtils.dialogs.resolveErrorMessage(b, i, h, d, c), !1 }), k === !1 ? (b.trigger("validation", !1), m.errorMsg = l, m.isValid = !1, m.shouldChangeDisplay = !0) : null === k ? m.shouldChangeDisplay = !1 : (b.trigger("validation", !0), m.shouldChangeDisplay = !0), "function" == typeof d.onElementValidate && null !== l && d.onElementValidate(m.isValid, b, e, l), b.trigger("afterValidation", [m, f]), m }, parseDate: function (b, c, d) { var e, f, g, h, i = c.replace(/[a-zA-Z]/gi, "").substring(0, 1), j = "^", k = c.split(i || null); if (a.each(k, function (a, b) { j += (a > 0 ? "\\" + i : "") + "(\\d{" + b.length + "})" }), j += "$", d) { var l = []; a.each(b.split(i), function (a, b) { 1 === b.length && (b = "0" + b), l.push(b) }), b = l.join(i) } if (e = b.match(new RegExp(j)), null === e) return !1; var m = function (b, c, d) { for (var e = 0; e < c.length; e++)if (c[e].substring(0, 1) === b) return a.formUtils.parseDateInt(d[e + 1]); return -1 }; return g = m("m", k, e), f = m("d", k, e), h = m("y", k, e), !(2 === g && f > 28 && (h % 4 !== 0 || h % 100 === 0 && h % 400 !== 0) || 2 === g && f > 29 && (h % 4 === 0 || h % 100 !== 0 && h % 400 === 0) || g > 12 || 0 === g) && (!(this.isShortMonth(g) && f > 30 || !this.isShortMonth(g) && f > 31 || 0 === f) && [h, g, f]) }, parseDateInt: function (a) { return 0 === a.indexOf("0") && (a = a.replace("0", "")), parseInt(a, 10) }, isShortMonth: function (a) { return a % 2 === 0 && a < 7 || a % 2 !== 0 && a > 7 }, lengthRestriction: function (b, c) { var d = parseInt(c.text(), 10), e = 0, f = function () { var a = b.val().length; if (a > d) { var f = b.scrollTop(); b.val(b.val().substring(0, d)), b.scrollTop(f) } e = d - a, e < 0 && (e = 0), c.text(e) }; a(b).bind("keydown keyup keypress focus blur", f).bind("cut paste", function () { setTimeout(f, 100) }), a(document).bind("ready", f) }, numericRangeCheck: function (b, c) { var d = a.split(c), e = parseInt(c.substr(3), 10); return 1 === d.length && c.indexOf("min") === -1 && c.indexOf("max") === -1 && (d = [c, c]), 2 === d.length && (b < parseInt(d[0], 10) || b > parseInt(d[1], 10)) ? ["out", d[0], d[1]] : 0 === c.indexOf("min") && b < e ? ["min", e] : 0 === c.indexOf("max") && b > e ? ["max", e] : ["ok"] }, _numSuggestionElements: 0, _selectedSuggestion: null, _previousTypedVal: null, suggest: function (b, d, e) { var f = { css: { maxHeight: "150px", background: "#FFF", lineHeight: "150%", textDecoration: "underline", overflowX: "hidden", overflowY: "auto", border: "#CCC solid 1px", borderTop: "none", cursor: "pointer" }, activeSuggestionCSS: { background: "#E9E9E9" } }, g = function (a, b) { var c = b.offset(); a.css({ width: b.outerWidth(), left: c.left + "px", top: c.top + b.outerHeight() + "px" }) }; e && a.extend(f, e), f.css.position = "absolute", f.css["z-index"] = 9999, b.attr("autocomplete", "off"), 0 === this._numSuggestionElements && c.bind("resize", function () { a(".jquery-form-suggestions").each(function () { var b = a(this), c = b.attr("data-suggest-container"); g(b, a(".suggestions-" + c).eq(0)) }) }), this._numSuggestionElements++; var h = function (b) { var c = b.valAttr("suggestion-nr"); a.formUtils._selectedSuggestion = null, a.formUtils._previousTypedVal = null, a(".jquery-form-suggestion-" + c).fadeOut("fast") }; return b.data("suggestions", d).valAttr("suggestion-nr", this._numSuggestionElements).unbind("focus.suggest").bind("focus.suggest", function () { a(this).trigger("keyup"), a.formUtils._selectedSuggestion = null }).unbind("keyup.suggest").bind("keyup.suggest", function () { var c = a(this), d = [], e = a.trim(c.val()).toLocaleLowerCase(); if (e !== a.formUtils._previousTypedVal) { a.formUtils._previousTypedVal = e; var i = !1, j = c.valAttr("suggestion-nr"), k = a(".jquery-form-suggestion-" + j); if (k.scrollTop(0), "" !== e) { var l = e.length > 2; a.each(c.data("suggestions"), function (a, b) { var c = b.toLocaleLowerCase(); return c === e ? (d.push("<strong>" + b + "</strong>"), i = !0, !1) : void ((0 === c.indexOf(e) || l && c.indexOf(e) > -1) && d.push(b.replace(new RegExp(e, "gi"), "<strong>$&</strong>"))) }) } i || 0 === d.length && k.length > 0 ? k.hide() : d.length > 0 && 0 === k.length ? (k = a("<div></div>").css(f.css).appendTo("body"), b.addClass("suggestions-" + j), k.attr("data-suggest-container", j).addClass("jquery-form-suggestions").addClass("jquery-form-suggestion-" + j)) : d.length > 0 && !k.is(":visible") && k.show(), d.length > 0 && e.length !== d[0].length && (g(k, c), k.html(""), a.each(d, function (b, d) { a("<div></div>").append(d).css({ overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap", padding: "5px" }).addClass("form-suggest-element").appendTo(k).click(function () { c.focus(), c.val(a(this).text()), c.trigger("change"), h(c) }) })) } }).unbind("keydown.validation").bind("keydown.validation", function (b) { var c, d, e = b.keyCode ? b.keyCode : b.which, g = a(this); if (13 === e && null !== a.formUtils._selectedSuggestion) { if (c = g.valAttr("suggestion-nr"), d = a(".jquery-form-suggestion-" + c), d.length > 0) { var i = d.find("div").eq(a.formUtils._selectedSuggestion).text(); g.val(i), g.trigger("change"), h(g), b.preventDefault() } } else { c = g.valAttr("suggestion-nr"), d = a(".jquery-form-suggestion-" + c); var j = d.children(); if (j.length > 0 && a.inArray(e, [38, 40]) > -1) { 38 === e ? (null === a.formUtils._selectedSuggestion ? a.formUtils._selectedSuggestion = j.length - 1 : a.formUtils._selectedSuggestion-- , a.formUtils._selectedSuggestion < 0 && (a.formUtils._selectedSuggestion = j.length - 1)) : 40 === e && (null === a.formUtils._selectedSuggestion ? a.formUtils._selectedSuggestion = 0 : a.formUtils._selectedSuggestion++ , a.formUtils._selectedSuggestion > j.length - 1 && (a.formUtils._selectedSuggestion = 0)); var k = d.innerHeight(), l = d.scrollTop(), m = d.children().eq(0).outerHeight(), n = m * a.formUtils._selectedSuggestion; return (n < l || n > l + k) && d.scrollTop(n), j.removeClass("active-suggestion").css("background", "none").eq(a.formUtils._selectedSuggestion).addClass("active-suggestion").css(f.activeSuggestionCSS), b.preventDefault(), !1 } } }).unbind("blur.suggest").bind("blur.suggest", function () { h(a(this)) }), b }, LANG: { errorTitle: "Form submission failed!", requiredField: "This is a required field", requiredFields: "You have not answered all required fields", badTime: "You have not given a correct time", badEmail: "You have not given a correct e-mail address", badTelephone: "You have not given a correct phone number", badSecurityAnswer: "You have not given a correct answer to the security question", badDate: "You have not given a correct date", lengthBadStart: "The input value must be between ", lengthBadEnd: " characters", lengthTooLongStart: "The input value is longer than ", lengthTooShortStart: "The input value is shorter than ", notConfirmed: "Input values could not be confirmed", badDomain: "Incorrect domain value", badUrl: "The input value is not a correct URL", badCustomVal: "The input value is incorrect", andSpaces: " and spaces ", badInt: "The input value was not a correct number", badSecurityNumber: "Your social security number was incorrect", badUKVatAnswer: "Incorrect UK VAT Number", badUKNin: "Incorrect UK NIN", badUKUtr: "Incorrect UK UTR Number", badStrength: "The password isn't strong enough", badNumberOfSelectedOptionsStart: "You have to choose at least ", badNumberOfSelectedOptionsEnd: " answers", badAlphaNumeric: "The input value can only contain alphanumeric characters ", badAlphaNumericExtra: " and ", wrongFileSize: "The file you are trying to upload is too large (max %s)", wrongFileType: "Only files of type %s is allowed", groupCheckedRangeStart: "Please choose between ", groupCheckedTooFewStart: "Please choose at least ", groupCheckedTooManyStart: "Please choose a maximum of ", groupCheckedEnd: " item(s)", badCreditCard: "The credit card number is not correct", badCVV: "The CVV number was not correct", wrongFileDim: "Incorrect image dimensions,", imageTooTall: "the image can not be taller than", imageTooWide: "the image can not be wider than", imageTooSmall: "the image was too small", min: "min", max: "max", imageRatioNotAccepted: "Image ratio is not be accepted", badBrazilTelephoneAnswer: "The phone number entered is invalid", badBrazilCEPAnswer: "The CEP entered is invalid", badBrazilCPFAnswer: "The CPF entered is invalid", badPlPesel: "The PESEL entered is invalid", badPlNip: "The NIP entered is invalid", badPlRegon: "The REGON entered is invalid", badreCaptcha: "Please confirm that you are not a bot", passwordComplexityStart: "Password must contain at least ", passwordComplexitySeparator: ", ", passwordComplexityUppercaseInfo: " uppercase letter(s)", passwordComplexityLowercaseInfo: " lowercase letter(s)", passwordComplexitySpecialCharsInfo: " special character(s)", passwordComplexityNumericCharsInfo: " numeric character(s)", passwordComplexityEnd: "." } }) }(a, window), function (a) {
    a.formUtils.addValidator({ name: "email", validatorFunction: function (b) { var c = b.toLowerCase().split("@"), d = c[0], e = c[1]; if (d && e) { if (0 === d.indexOf('"')) { var f = d.length; if (d = d.replace(/\"/g, ""), d.length !== f - 2) return !1 } return a.formUtils.validators.validate_domain.validatorFunction(c[1]) && 0 !== d.indexOf(".") && "." !== d.substring(d.length - 1, d.length) && d.indexOf("..") === -1 && !/[^\w\+\.\-\#\-\_\~\!\$\&\'\(\)\*\+\,\;\=\:]/.test(d) } return !1 }, errorMessage: "", errorMessageKey: "badEmail" }), a.formUtils.addValidator({ name: "domain", validatorFunction: function (a) { return a.length > 0 && a.length <= 253 && !/[^a-zA-Z0-9]/.test(a.slice(-2)) && !/[^a-zA-Z0-9]/.test(a.substr(0, 1)) && !/[^a-zA-Z0-9\.\-]/.test(a) && 1 === a.split("..").length && a.split(".").length > 1 }, errorMessage: "", errorMessageKey: "badDomain" }), a.formUtils.addValidator({ name: "required", validatorFunction: function (b, c, d, e, f) { switch (c.attr("type")) { case "checkbox": return c.is(":checked"); case "radio": return f.find('input[name="' + c.attr("name") + '"]').filter(":checked").length > 0; default: return "" !== a.trim(b) } }, errorMessage: "", errorMessageKey: function (a) { return "top" === a.errorMessagePosition || "function" == typeof a.errorMessagePosition ? "requiredFields" : "requiredField" } }), a.formUtils.addValidator({ name: "length", validatorFunction: function (b, c, d, e) { var f = c.valAttr("length"), g = c.attr("type"); if (void 0 === f) return alert('Please add attribute "data-validation-length" to ' + c[0].nodeName + " named " + c.attr("name")), !0; var h, i = "file" === g && void 0 !== c.get(0).files ? c.get(0).files.length : b.length, j = a.formUtils.numericRangeCheck(i, f); switch (j[0]) { case "out": this.errorMessage = e.lengthBadStart + f + e.lengthBadEnd, h = !1; break; case "min": this.errorMessage = e.lengthTooShortStart + j[1] + e.lengthBadEnd, h = !1; break; case "max": this.errorMessage = e.lengthTooLongStart + j[1] + e.lengthBadEnd, h = !1; break; default: h = !0 }return h }, errorMessage: "", errorMessageKey: "" }), a.formUtils.addValidator({ name: "url", validatorFunction: function (b) { var c = /^(https?|ftp):\/\/((((\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])(\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])(\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/(((\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/((\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|\[|\]|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#(((\w|-|\.|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i; if (c.test(b)) { var d = b.split("://")[1], e = d.indexOf("/"); return e > -1 && (d = d.substr(0, e)), a.formUtils.validators.validate_domain.validatorFunction(d) } return !1 }, errorMessage: "", errorMessageKey: "badUrl" }), a.formUtils.addValidator({ name: "number", validatorFunction: function (a, b, c) { if ("" !== a) { var d, e, f = b.valAttr("allowing") || "", g = b.valAttr("decimal-separator") || c.decimalSeparator, h = !1, i = b.valAttr("step") || "", j = !1, k = b.attr("data-sanitize") || "", l = k.match(/(^|[\s])numberFormat([\s]|$)/i); if (l) { if (!window.numeral) throw new ReferenceError("The data-sanitize value numberFormat cannot be used without the numeral library. Please see Data Validation in http://www.formvalidator.net for more information."); a.length && (a = String(numeral().unformat(a))) } if (f.indexOf("number") === -1 && (f += ",number"), f.indexOf("negative") === -1 && 0 === a.indexOf("-")) return !1; if (f.indexOf("range") > -1 && (d = parseFloat(f.substring(f.indexOf("[") + 1, f.indexOf(";"))), e = parseFloat(f.substring(f.indexOf(";") + 1, f.indexOf("]"))), h = !0), "" !== i && (j = !0), "," === g) { if (a.indexOf(".") > -1) return !1; a = a.replace(",", ".") } if ("" === a.replace(/[0-9-]/g, "") && (!h || a >= d && a <= e) && (!j || a % i === 0)) return !0; if (f.indexOf("float") > -1 && null !== a.match(new RegExp("^([0-9-]+)\\.([0-9]+)$")) && (!h || a >= d && a <= e) && (!j || a % i === 0)) return !0 } return !1 }, errorMessage: "", errorMessageKey: "badInt" }), a.formUtils.addValidator({
        name: "alphanumeric", validatorFunction: function (b, c, d, e) {
            var f = "^([a-zA-Z0-9", g = "]+)$", h = c.valAttr("allowing"), i = "", j = !1; if (h) {
                i = f + h + g; var k = h.replace(/\\/g, ""); k.indexOf(" ") > -1 && (j = !0, k = k.replace(" ", ""), k += e.andSpaces || a.formUtils.LANG.andSpaces), e.badAlphaNumericAndExtraAndSpaces && e.badAlphaNumericAndExtra ? j ? this.errorMessage = e.badAlphaNumericAndExtraAndSpaces + k : this.errorMessage = e.badAlphaNumericAndExtra + k + e.badAlphaNumericExtra : this.errorMessage = e.badAlphaNumeric + e.badAlphaNumericExtra + k;
            } else i = f + g, this.errorMessage = e.badAlphaNumeric; return new RegExp(i).test(b)
        }, errorMessage: "", errorMessageKey: ""
    }), a.formUtils.addValidator({ name: "custom", validatorFunction: function (a, b) { var c = new RegExp(b.valAttr("regexp")); return c.test(a) }, errorMessage: "", errorMessageKey: "badCustomVal" }), a.formUtils.addValidator({ name: "date", validatorFunction: function (b, c, d) { var e = c.valAttr("format") || d.dateFormat || "yyyy-mm-dd", f = "false" === c.valAttr("require-leading-zero"); return a.formUtils.parseDate(b, e, f) !== !1 }, errorMessage: "", errorMessageKey: "badDate" }), a.formUtils.addValidator({ name: "checkbox_group", validatorFunction: function (b, c, d, e, f) { var g = !0, h = c.attr("name"), i = a('input[type=checkbox][name^="' + h + '"]', f), j = i.filter(":checked").length, k = c.valAttr("qty"); if (void 0 === k) { var l = c.get(0).nodeName; alert('Attribute "data-validation-qty" is missing from ' + l + " named " + c.attr("name")) } var m = a.formUtils.numericRangeCheck(j, k); switch (m[0]) { case "out": this.errorMessage = e.groupCheckedRangeStart + k + e.groupCheckedEnd, g = !1; break; case "min": this.errorMessage = e.groupCheckedTooFewStart + m[1] + (e.groupCheckedTooFewEnd || e.groupCheckedEnd), g = !1; break; case "max": this.errorMessage = e.groupCheckedTooManyStart + m[1] + (e.groupCheckedTooManyEnd || e.groupCheckedEnd), g = !1; break; default: g = !0 }if (!g) { var n = function () { i.unbind("click", n), i.filter("*[data-validation]").validateInputOnBlur(e, d, !1, "blur") }; i.bind("click", n) } return g } })
}(a)
});

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {
		define( ["jquery"], factory );
	} else if (typeof module === "object" && module.exports) {
		module.exports = factory( require( "jquery" ) );
	} else {
		factory( jQuery );
	}
}(function( $ ) {

$.extend( $.fn, {

	// https://jqueryvalidation.org/validate/
	validate: function( options ) {

		// If nothing is selected, return nothing; can't chain anyway
		if ( !this.length ) {
			if ( options && options.debug && window.console ) {
				console.warn( "Nothing selected, can't validate, returning nothing." );
			}
			return;
		}

		// Check if a validator for this form was already created
		var validator = $.data( this[ 0 ], "validator" );
		if ( validator ) {
			return validator;
		}

		// Add novalidate tag if HTML5.
		this.attr( "novalidate", "novalidate" );

		validator = new $.validator( options, this[ 0 ] );
		$.data( this[ 0 ], "validator", validator );

		if ( validator.settings.onsubmit ) {

			this.on( "click.validate", ":submit", function( event ) {

				// Track the used submit button to properly handle scripted
				// submits later.
				validator.submitButton = event.currentTarget;

				// Allow suppressing validation by adding a cancel class to the submit button
				if ( $( this ).hasClass( "cancel" ) ) {
					validator.cancelSubmit = true;
				}

				// Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
				if ( $( this ).attr( "formnovalidate" ) !== undefined ) {
					validator.cancelSubmit = true;
				}
			} );

			// Validate the form on submit
			this.on( "submit.validate", function( event ) {
				if ( validator.settings.debug ) {

					// Prevent form submit to be able to see console output
					event.preventDefault();
				}

				function handle() {
					var hidden, result;

					// Insert a hidden input as a replacement for the missing submit button
					// The hidden input is inserted in two cases:
					//   - A user defined a `submitHandler`
					//   - There was a pending request due to `remote` method and `stopRequest()`
					//     was called to submit the form in case it's valid
					if ( validator.submitButton && ( validator.settings.submitHandler || validator.formSubmitted ) ) {
						hidden = $( "<input type='hidden'/>" )
							.attr( "name", validator.submitButton.name )
							.val( $( validator.submitButton ).val() )
							.appendTo( validator.currentForm );
					}

					if ( validator.settings.submitHandler && !validator.settings.debug ) {
						result = validator.settings.submitHandler.call( validator, validator.currentForm, event );
						if ( hidden ) {

							// And clean up afterwards; thanks to no-block-scope, hidden can be referenced
							hidden.remove();
						}
						if ( result !== undefined ) {
							return result;
						}
						return false;
					}
					return true;
				}

				// Prevent submit for invalid forms or custom submit handlers
				if ( validator.cancelSubmit ) {
					validator.cancelSubmit = false;
					return handle();
				}
				if ( validator.form() ) {
					if ( validator.pendingRequest ) {
						validator.formSubmitted = true;
						return false;
					}
					return handle();
				} else {
					validator.focusInvalid();
					return false;
				}
			} );
		}

		return validator;
	},

	// https://jqueryvalidation.org/valid/
	valid: function() {
		var valid, validator, errorList;

		if ( $( this[ 0 ] ).is( "form" ) ) {
			valid = this.validate().form();
		} else {
			errorList = [];
			valid = true;
			validator = $( this[ 0 ].form ).validate();
			this.each( function() {
				valid = validator.element( this ) && valid;
				if ( !valid ) {
					errorList = errorList.concat( validator.errorList );
				}
			} );
			validator.errorList = errorList;
		}
		return valid;
	},

	// https://jqueryvalidation.org/rules/
	rules: function( command, argument ) {
		var element = this[ 0 ],
			isContentEditable = typeof this.attr( "contenteditable" ) !== "undefined" && this.attr( "contenteditable" ) !== "false",
			settings, staticRules, existingRules, data, param, filtered;

		// If nothing is selected, return empty object; can't chain anyway
		if ( element == null ) {
			return;
		}

		if ( !element.form && isContentEditable ) {
			element.form = this.closest( "form" )[ 0 ];
			element.name = this.attr( "name" );
		}

		if ( element.form == null ) {
			return;
		}

		if ( command ) {
			settings = $.data( element.form, "validator" ).settings;
			staticRules = settings.rules;
			existingRules = $.validator.staticRules( element );
			switch ( command ) {
			case "add":
				$.extend( existingRules, $.validator.normalizeRule( argument ) );

				// Remove messages from rules, but allow them to be set separately
				delete existingRules.messages;
				staticRules[ element.name ] = existingRules;
				if ( argument.messages ) {
					settings.messages[ element.name ] = $.extend( settings.messages[ element.name ], argument.messages );
				}
				break;
			case "remove":
				if ( !argument ) {
					delete staticRules[ element.name ];
					return existingRules;
				}
				filtered = {};
				$.each( argument.split( /\s/ ), function( index, method ) {
					filtered[ method ] = existingRules[ method ];
					delete existingRules[ method ];
				} );
				return filtered;
			}
		}

		data = $.validator.normalizeRules(
		$.extend(
			{},
			$.validator.classRules( element ),
			$.validator.attributeRules( element ),
			$.validator.dataRules( element ),
			$.validator.staticRules( element )
		), element );

		// Make sure required is at front
		if ( data.required ) {
			param = data.required;
			delete data.required;
			data = $.extend( { required: param }, data );
		}

		// Make sure remote is at back
		if ( data.remote ) {
			param = data.remote;
			delete data.remote;
			data = $.extend( data, { remote: param } );
		}

		return data;
	}
} );

// Custom selectors
$.extend( $.expr.pseudos || $.expr[ ":" ], {		// '|| $.expr[ ":" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support

	// https://jqueryvalidation.org/blank-selector/
	blank: function( a ) {
		return !$.trim( "" + $( a ).val() );
	},

	// https://jqueryvalidation.org/filled-selector/
	filled: function( a ) {
		var val = $( a ).val();
		return val !== null && !!$.trim( "" + val );
	},

	// https://jqueryvalidation.org/unchecked-selector/
	unchecked: function( a ) {
		return !$( a ).prop( "checked" );
	}
} );

// Constructor for validator
$.validator = function( options, form ) {
	this.settings = $.extend( true, {}, $.validator.defaults, options );
	this.currentForm = form;
	this.init();
};

// https://jqueryvalidation.org/jQuery.validator.format/
$.validator.format = function( source, params ) {
	if ( arguments.length === 1 ) {
		return function() {
			var args = $.makeArray( arguments );
			args.unshift( source );
			return $.validator.format.apply( this, args );
		};
	}
	if ( params === undefined ) {
		return source;
	}
	if ( arguments.length > 2 && params.constructor !== Array  ) {
		params = $.makeArray( arguments ).slice( 1 );
	}
	if ( params.constructor !== Array ) {
		params = [ params ];
	}
	$.each( params, function( i, n ) {
		source = source.replace( new RegExp( "\\{" + i + "\\}", "g" ), function() {
			return n;
		} );
	} );
	return source;
};

$.extend( $.validator, {

	defaults: {
		messages: {},
		groups: {},
		rules: {},
		errorClass: "error",
		pendingClass: "pending",
		validClass: "valid",
		errorElement: "label",
		focusCleanup: false,
		focusInvalid: true,
		errorContainer: $( [] ),
		errorLabelContainer: $( [] ),
		onsubmit: true,
		ignore: ":hidden",
		ignoreTitle: false,
		onfocusin: function( element ) {
			this.lastActive = element;

			// Hide error label and remove error class on focus if enabled
			if ( this.settings.focusCleanup ) {
				if ( this.settings.unhighlight ) {
					this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
				}
				this.hideThese( this.errorsFor( element ) );
			}
		},
		onfocusout: function( element ) {
			if ( !this.checkable( element ) && ( element.name in this.submitted || !this.optional( element ) ) ) {
				this.element( element );
			}
		},
		onkeyup: function( element, event ) {

			// Avoid revalidate the field when pressing one of the following keys
			// Shift       => 16
			// Ctrl        => 17
			// Alt         => 18
			// Caps lock   => 20
			// End         => 35
			// Home        => 36
			// Left arrow  => 37
			// Up arrow    => 38
			// Right arrow => 39
			// Down arrow  => 40
			// Insert      => 45
			// Num lock    => 144
			// AltGr key   => 225
			var excludedKeys = [
				16, 17, 18, 20, 35, 36, 37,
				38, 39, 40, 45, 144, 225
			];

			if ( event.which === 9 && this.elementValue( element ) === "" || $.inArray( event.keyCode, excludedKeys ) !== -1 ) {
				return;
			} else if ( element.name in this.submitted || element.name in this.invalid ) {
				this.element( element );
			}
		},
		onclick: function( element ) {

			// Click on selects, radiobuttons and checkboxes
			if ( element.name in this.submitted ) {
				this.element( element );

			// Or option elements, check parent select in that case
			} else if ( element.parentNode.name in this.submitted ) {
				this.element( element.parentNode );
			}
		},
		highlight: function( element, errorClass, validClass ) {
			if ( element.type === "radio" ) {
				this.findByName( element.name ).addClass( errorClass ).removeClass( validClass );
			} else {
				$( element ).addClass( errorClass ).removeClass( validClass );
			}
		},
		unhighlight: function( element, errorClass, validClass ) {
			if ( element.type === "radio" ) {
				this.findByName( element.name ).removeClass( errorClass ).addClass( validClass );
			} else {
				$( element ).removeClass( errorClass ).addClass( validClass );
			}
		}
	},

	// https://jqueryvalidation.org/jQuery.validator.setDefaults/
	setDefaults: function( settings ) {
		$.extend( $.validator.defaults, settings );
	},

	messages: {
		required: "This field is required.",
		remote: "Please fix this field.",
		email: "Please enter a valid email address.",
		url: "Please enter a valid URL.",
		date: "Please enter a valid date.",
		dateISO: "Please enter a valid date (ISO).",
		number: "Please enter a valid number.",
		digits: "Please enter only digits.",
		equalTo: "Please enter the same value again.",
		maxlength: $.validator.format( "Please enter no more than {0} characters." ),
		minlength: $.validator.format( "Please enter at least {0} characters." ),
		rangelength: $.validator.format( "Please enter a value between {0} and {1} characters long." ),
		range: $.validator.format( "Please enter a value between {0} and {1}." ),
		max: $.validator.format( "Please enter a value less than or equal to {0}." ),
		min: $.validator.format( "Please enter a value greater than or equal to {0}." ),
		step: $.validator.format( "Please enter a multiple of {0}." )
	},

	autoCreateRanges: false,

	prototype: {

		init: function() {
			this.labelContainer = $( this.settings.errorLabelContainer );
			this.errorContext = this.labelContainer.length && this.labelContainer || $( this.currentForm );
			this.containers = $( this.settings.errorContainer ).add( this.settings.errorLabelContainer );
			this.submitted = {};
			this.valueCache = {};
			this.pendingRequest = 0;
			this.pending = {};
			this.invalid = {};
			this.reset();

			var currentForm = this.currentForm,
				groups = ( this.groups = {} ),
				rules;
			$.each( this.settings.groups, function( key, value ) {
				if ( typeof value === "string" ) {
					value = value.split( /\s/ );
				}
				$.each( value, function( index, name ) {
					groups[ name ] = key;
				} );
			} );
			rules = this.settings.rules;
			$.each( rules, function( key, value ) {
				rules[ key ] = $.validator.normalizeRule( value );
			} );

			function delegate( event ) {
				var isContentEditable = typeof $( this ).attr( "contenteditable" ) !== "undefined" && $( this ).attr( "contenteditable" ) !== "false";

				// Set form expando on contenteditable
				if ( !this.form && isContentEditable ) {
					this.form = $( this ).closest( "form" )[ 0 ];
					this.name = $( this ).attr( "name" );
				}

				// Ignore the element if it belongs to another form. This will happen mainly
				// when setting the `form` attribute of an input to the id of another form.
				if ( currentForm !== this.form ) {
					return;
				}

				var validator = $.data( this.form, "validator" ),
					eventType = "on" + event.type.replace( /^validate/, "" ),
					settings = validator.settings;
				if ( settings[ eventType ] && !$( this ).is( settings.ignore ) ) {
					settings[ eventType ].call( validator, this, event );
				}
			}

			$( this.currentForm )
				.on( "focusin.validate focusout.validate keyup.validate",
					":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], " +
					"[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], " +
					"[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], " +
					"[type='radio'], [type='checkbox'], [contenteditable], [type='button']", delegate )

				// Support: Chrome, oldIE
				// "select" is provided as event.target when clicking a option
				.on( "click.validate", "select, option, [type='radio'], [type='checkbox']", delegate );

			if ( this.settings.invalidHandler ) {
				$( this.currentForm ).on( "invalid-form.validate", this.settings.invalidHandler );
			}
		},

		// https://jqueryvalidation.org/Validator.form/
		form: function() {
			this.checkForm();
			$.extend( this.submitted, this.errorMap );
			this.invalid = $.extend( {}, this.errorMap );
			if ( !this.valid() ) {
				$( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
			}
			this.showErrors();
			return this.valid();
		},

		checkForm: function() {
			this.prepareForm();
			for ( var i = 0, elements = ( this.currentElements = this.elements() ); elements[ i ]; i++ ) {
				this.check( elements[ i ] );
			}
			return this.valid();
		},

		// https://jqueryvalidation.org/Validator.element/
		element: function( element ) {
			var cleanElement = this.clean( element ),
				checkElement = this.validationTargetFor( cleanElement ),
				v = this,
				result = true,
				rs, group;

			if ( checkElement === undefined ) {
				delete this.invalid[ cleanElement.name ];
			} else {
				this.prepareElement( checkElement );
				this.currentElements = $( checkElement );

				// If this element is grouped, then validate all group elements already
				// containing a value
				group = this.groups[ checkElement.name ];
				if ( group ) {
					$.each( this.groups, function( name, testgroup ) {
						if ( testgroup === group && name !== checkElement.name ) {
							cleanElement = v.validationTargetFor( v.clean( v.findByName( name ) ) );
							if ( cleanElement && cleanElement.name in v.invalid ) {
								v.currentElements.push( cleanElement );
								result = v.check( cleanElement ) && result;
							}
						}
					} );
				}

				rs = this.check( checkElement ) !== false;
				result = result && rs;
				if ( rs ) {
					this.invalid[ checkElement.name ] = false;
				} else {
					this.invalid[ checkElement.name ] = true;
				}

				if ( !this.numberOfInvalids() ) {

					// Hide error containers on last error
					this.toHide = this.toHide.add( this.containers );
				}
				this.showErrors();

				// Add aria-invalid status for screen readers
				$( element ).attr( "aria-invalid", !rs );
			}

			return result;
		},

		// https://jqueryvalidation.org/Validator.showErrors/
		showErrors: function( errors ) {
			if ( errors ) {
				var validator = this;

				// Add items to error list and map
				$.extend( this.errorMap, errors );
				this.errorList = $.map( this.errorMap, function( message, name ) {
					return {
						message: message,
						element: validator.findByName( name )[ 0 ]
					};
				} );

				// Remove items from success list
				this.successList = $.grep( this.successList, function( element ) {
					return !( element.name in errors );
				} );
			}
			if ( this.settings.showErrors ) {
				this.settings.showErrors.call( this, this.errorMap, this.errorList );
			} else {
				this.defaultShowErrors();
			}
		},

		// https://jqueryvalidation.org/Validator.resetForm/
		resetForm: function() {
			if ( $.fn.resetForm ) {
				$( this.currentForm ).resetForm();
			}
			this.invalid = {};
			this.submitted = {};
			this.prepareForm();
			this.hideErrors();
			var elements = this.elements()
				.removeData( "previousValue" )
				.removeAttr( "aria-invalid" );

			this.resetElements( elements );
		},

		resetElements: function( elements ) {
			var i;

			if ( this.settings.unhighlight ) {
				for ( i = 0; elements[ i ]; i++ ) {
					this.settings.unhighlight.call( this, elements[ i ],
						this.settings.errorClass, "" );
					this.findByName( elements[ i ].name ).removeClass( this.settings.validClass );
				}
			} else {
				elements
					.removeClass( this.settings.errorClass )
					.removeClass( this.settings.validClass );
			}
		},

		numberOfInvalids: function() {
			return this.objectLength( this.invalid );
		},

		objectLength: function( obj ) {
			/* jshint unused: false */
			var count = 0,
				i;
			for ( i in obj ) {

				// This check allows counting elements with empty error
				// message as invalid elements
				if ( obj[ i ] !== undefined && obj[ i ] !== null && obj[ i ] !== false ) {
					count++;
				}
			}
			return count;
		},

		hideErrors: function() {
			this.hideThese( this.toHide );
		},

		hideThese: function( errors ) {
			errors.not( this.containers ).text( "" );
			this.addWrapper( errors ).hide();
		},

		valid: function() {
			return this.size() === 0;
		},

		size: function() {
			return this.errorList.length;
		},

		focusInvalid: function() {
			if ( this.settings.focusInvalid ) {
				try {
					$( this.findLastActive() || this.errorList.length && this.errorList[ 0 ].element || [] )
					.filter( ":visible" )
					.trigger( "focus" )

					// Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
					.trigger( "focusin" );
				} catch ( e ) {

					// Ignore IE throwing errors when focusing hidden elements
				}
			}
		},

		findLastActive: function() {
			var lastActive = this.lastActive;
			return lastActive && $.grep( this.errorList, function( n ) {
				return n.element.name === lastActive.name;
			} ).length === 1 && lastActive;
		},

		elements: function() {
			var validator = this,
				rulesCache = {};

			// Select all valid inputs inside the form (no submit or reset buttons)
			return $( this.currentForm )
			.find( "input, select, textarea, [contenteditable]" )
			.not( ":submit, :reset, :image, :disabled" )
			.not( this.settings.ignore )
			.filter( function() {
				var name = this.name || $( this ).attr( "name" ); // For contenteditable
				var isContentEditable = typeof $( this ).attr( "contenteditable" ) !== "undefined" && $( this ).attr( "contenteditable" ) !== "false";

				if ( !name && validator.settings.debug && window.console ) {
					console.error( "%o has no name assigned", this );
				}

				// Set form expando on contenteditable
				if ( isContentEditable ) {
					this.form = $( this ).closest( "form" )[ 0 ];
					this.name = name;
				}

				// Ignore elements that belong to other/nested forms
				if ( this.form !== validator.currentForm ) {
					return false;
				}

				// Select only the first element for each name, and only those with rules specified
				if ( name in rulesCache || !validator.objectLength( $( this ).rules() ) ) {
					return false;
				}

				rulesCache[ name ] = true;
				return true;
			} );
		},

		clean: function( selector ) {
			return $( selector )[ 0 ];
		},

		errors: function() {
			var errorClass = this.settings.errorClass.split( " " ).join( "." );
			return $( this.settings.errorElement + "." + errorClass, this.errorContext );
		},

		resetInternals: function() {
			this.successList = [];
			this.errorList = [];
			this.errorMap = {};
			this.toShow = $( [] );
			this.toHide = $( [] );
		},

		reset: function() {
			this.resetInternals();
			this.currentElements = $( [] );
		},

		prepareForm: function() {
			this.reset();
			this.toHide = this.errors().add( this.containers );
		},

		prepareElement: function( element ) {
			this.reset();
			this.toHide = this.errorsFor( element );
		},

		elementValue: function( element ) {
			var $element = $( element ),
				type = element.type,
				isContentEditable = typeof $element.attr( "contenteditable" ) !== "undefined" && $element.attr( "contenteditable" ) !== "false",
				val, idx;

			if ( type === "radio" || type === "checkbox" ) {
				return this.findByName( element.name ).filter( ":checked" ).val();
			} else if ( type === "number" && typeof element.validity !== "undefined" ) {
				return element.validity.badInput ? "NaN" : $element.val();
			}

			if ( isContentEditable ) {
				val = $element.text();
			} else {
				val = $element.val();
			}

			if ( type === "file" ) {

				// Modern browser (chrome & safari)
				if ( val.substr( 0, 12 ) === "C:\\fakepath\\" ) {
					return val.substr( 12 );
				}

				// Legacy browsers
				// Unix-based path
				idx = val.lastIndexOf( "/" );
				if ( idx >= 0 ) {
					return val.substr( idx + 1 );
				}

				// Windows-based path
				idx = val.lastIndexOf( "\\" );
				if ( idx >= 0 ) {
					return val.substr( idx + 1 );
				}

				// Just the file name
				return val;
			}

			if ( typeof val === "string" ) {
				return val.replace( /\r/g, "" );
			}
			return val;
		},

		check: function( element ) {
			element = this.validationTargetFor( this.clean( element ) );

			var rules = $( element ).rules(),
				rulesCount = $.map( rules, function( n, i ) {
					return i;
				} ).length,
				dependencyMismatch = false,
				val = this.elementValue( element ),
				result, method, rule, normalizer;

			// Prioritize the local normalizer defined for this element over the global one
			// if the former exists, otherwise user the global one in case it exists.
			if ( typeof rules.normalizer === "function" ) {
				normalizer = rules.normalizer;
			} else if (	typeof this.settings.normalizer === "function" ) {
				normalizer = this.settings.normalizer;
			}

			// If normalizer is defined, then call it to retreive the changed value instead
			// of using the real one.
			// Note that `this` in the normalizer is `element`.
			if ( normalizer ) {
				val = normalizer.call( element, val );

				// Delete the normalizer from rules to avoid treating it as a pre-defined method.
				delete rules.normalizer;
			}

			for ( method in rules ) {
				rule = { method: method, parameters: rules[ method ] };
				try {
					result = $.validator.methods[ method ].call( this, val, element, rule.parameters );

					// If a method indicates that the field is optional and therefore valid,
					// don't mark it as valid when there are no other rules
					if ( result === "dependency-mismatch" && rulesCount === 1 ) {
						dependencyMismatch = true;
						continue;
					}
					dependencyMismatch = false;

					if ( result === "pending" ) {
						this.toHide = this.toHide.not( this.errorsFor( element ) );
						return;
					}

					if ( !result ) {
						this.formatAndAdd( element, rule );
						return false;
					}
				} catch ( e ) {
					if ( this.settings.debug && window.console ) {
						console.log( "Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e );
					}
					if ( e instanceof TypeError ) {
						e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.";
					}

					throw e;
				}
			}
			if ( dependencyMismatch ) {
				return;
			}
			if ( this.objectLength( rules ) ) {
				this.successList.push( element );
			}
			return true;
		},

		// Return the custom message for the given element and validation method
		// specified in the element's HTML5 data attribute
		// return the generic message if present and no method specific message is present
		customDataMessage: function( element, method ) {
			return $( element ).data( "msg" + method.charAt( 0 ).toUpperCase() +
				method.substring( 1 ).toLowerCase() ) || $( element ).data( "msg" );
		},

		// Return the custom message for the given element name and validation method
		customMessage: function( name, method ) {
			var m = this.settings.messages[ name ];
			return m && ( m.constructor === String ? m : m[ method ] );
		},

		// Return the first defined argument, allowing empty strings
		findDefined: function() {
			for ( var i = 0; i < arguments.length; i++ ) {
				if ( arguments[ i ] !== undefined ) {
					return arguments[ i ];
				}
			}
			return undefined;
		},

		// The second parameter 'rule' used to be a string, and extended to an object literal
		// of the following form:
		// rule = {
		//     method: "method name",
		//     parameters: "the given method parameters"
		// }
		//
		// The old behavior still supported, kept to maintain backward compatibility with
		// old code, and will be removed in the next major release.
		defaultMessage: function( element, rule ) {
			if ( typeof rule === "string" ) {
				rule = { method: rule };
			}

			var message = this.findDefined(
					this.customMessage( element.name, rule.method ),
					this.customDataMessage( element, rule.method ),

					// 'title' is never undefined, so handle empty string as undefined
					!this.settings.ignoreTitle && element.title || undefined,
					$.validator.messages[ rule.method ],
					"<strong>Warning: No message defined for " + element.name + "</strong>"
				),
				theregex = /\$?\{(\d+)\}/g;
			if ( typeof message === "function" ) {
				message = message.call( this, rule.parameters, element );
			} else if ( theregex.test( message ) ) {
				message = $.validator.format( message.replace( theregex, "{$1}" ), rule.parameters );
			}

			return message;
		},

		formatAndAdd: function( element, rule ) {
			var message = this.defaultMessage( element, rule );

			this.errorList.push( {
				message: message,
				element: element,
				method: rule.method
			} );

			this.errorMap[ element.name ] = message;
			this.submitted[ element.name ] = message;
		},

		addWrapper: function( toToggle ) {
			if ( this.settings.wrapper ) {
				toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
			}
			return toToggle;
		},

		defaultShowErrors: function() {
			var i, elements, error;
			for ( i = 0; this.errorList[ i ]; i++ ) {
				error = this.errorList[ i ];
				if ( this.settings.highlight ) {
					this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
				}
				this.showLabel( error.element, error.message );
			}
			if ( this.errorList.length ) {
				this.toShow = this.toShow.add( this.containers );
			}
			if ( this.settings.success ) {
				for ( i = 0; this.successList[ i ]; i++ ) {
					this.showLabel( this.successList[ i ] );
				}
			}
			if ( this.settings.unhighlight ) {
				for ( i = 0, elements = this.validElements(); elements[ i ]; i++ ) {
					this.settings.unhighlight.call( this, elements[ i ], this.settings.errorClass, this.settings.validClass );
				}
			}
			this.toHide = this.toHide.not( this.toShow );
			this.hideErrors();
			this.addWrapper( this.toShow ).show();
		},

		validElements: function() {
			return this.currentElements.not( this.invalidElements() );
		},

		invalidElements: function() {
			return $( this.errorList ).map( function() {
				return this.element;
			} );
		},

		showLabel: function( element, message ) {
			var place, group, errorID, v,
				error = this.errorsFor( element ),
				elementID = this.idOrName( element ),
				describedBy = $( element ).attr( "aria-describedby" );

			if ( error.length ) {

				// Refresh error/success class
				error.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );

				// Replace message on existing label
				error.html( message );
			} else {

				// Create error element
				error = $( "<" + this.settings.errorElement + ">" )
					.attr( "id", elementID + "-error" )
					.addClass( this.settings.errorClass )
					.html( message || "" );

				// Maintain reference to the element to be placed into the DOM
				place = error;
				if ( this.settings.wrapper ) {

					// Make sure the element is visible, even in IE
					// actually showing the wrapped element is handled elsewhere
					place = error.hide().show().wrap( "<" + this.settings.wrapper + "/>" ).parent();
				}
				if ( this.labelContainer.length ) {
					this.labelContainer.append( place );
				} else if ( this.settings.errorPlacement ) {
					this.settings.errorPlacement.call( this, place, $( element ) );
				} else {
					place.insertAfter( element );
				}

				// Link error back to the element
				if ( error.is( "label" ) ) {

					// If the error is a label, then associate using 'for'
					error.attr( "for", elementID );

					// If the element is not a child of an associated label, then it's necessary
					// to explicitly apply aria-describedby
				} else if ( error.parents( "label[for='" + this.escapeCssMeta( elementID ) + "']" ).length === 0 ) {
					errorID = error.attr( "id" );

					// Respect existing non-error aria-describedby
					if ( !describedBy ) {
						describedBy = errorID;
					} else if ( !describedBy.match( new RegExp( "\\b" + this.escapeCssMeta( errorID ) + "\\b" ) ) ) {

						// Add to end of list if not already present
						describedBy += " " + errorID;
					}
					$( element ).attr( "aria-describedby", describedBy );

					// If this element is grouped, then assign to all elements in the same group
					group = this.groups[ element.name ];
					if ( group ) {
						v = this;
						$.each( v.groups, function( name, testgroup ) {
							if ( testgroup === group ) {
								$( "[name='" + v.escapeCssMeta( name ) + "']", v.currentForm )
									.attr( "aria-describedby", error.attr( "id" ) );
							}
						} );
					}
				}
			}
			if ( !message && this.settings.success ) {
				error.text( "" );
				if ( typeof this.settings.success === "string" ) {
					error.addClass( this.settings.success );
				} else {
					this.settings.success( error, element );
				}
			}
			this.toShow = this.toShow.add( error );
		},

		errorsFor: function( element ) {
			var name = this.escapeCssMeta( this.idOrName( element ) ),
				describer = $( element ).attr( "aria-describedby" ),
				selector = "label[for='" + name + "'], label[for='" + name + "'] *";

			// 'aria-describedby' should directly reference the error element
			if ( describer ) {
				selector = selector + ", #" + this.escapeCssMeta( describer )
					.replace( /\s+/g, ", #" );
			}

			return this
				.errors()
				.filter( selector );
		},

		// See https://api.jquery.com/category/selectors/, for CSS
		// meta-characters that should be escaped in order to be used with JQuery
		// as a literal part of a name/id or any selector.
		escapeCssMeta: function( string ) {
			return string.replace( /([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1" );
		},

		idOrName: function( element ) {
			return this.groups[ element.name ] || ( this.checkable( element ) ? element.name : element.id || element.name );
		},

		validationTargetFor: function( element ) {

			// If radio/checkbox, validate first element in group instead
			if ( this.checkable( element ) ) {
				element = this.findByName( element.name );
			}

			// Always apply ignore filter
			return $( element ).not( this.settings.ignore )[ 0 ];
		},

		checkable: function( element ) {
			return ( /radio|checkbox/i ).test( element.type );
		},

		findByName: function( name ) {
			return $( this.currentForm ).find( "[name='" + this.escapeCssMeta( name ) + "']" );
		},

		getLength: function( value, element ) {
			switch ( element.nodeName.toLowerCase() ) {
			case "select":
				return $( "option:selected", element ).length;
			case "input":
				if ( this.checkable( element ) ) {
					return this.findByName( element.name ).filter( ":checked" ).length;
				}
			}
			return value.length;
		},

		depend: function( param, element ) {
			return this.dependTypes[ typeof param ] ? this.dependTypes[ typeof param ]( param, element ) : true;
		},

		dependTypes: {
			"boolean": function( param ) {
				return param;
			},
			"string": function( param, element ) {
				return !!$( param, element.form ).length;
			},
			"function": function( param, element ) {
				return param( element );
			}
		},

		optional: function( element ) {
			var val = this.elementValue( element );
			return !$.validator.methods.required.call( this, val, element ) && "dependency-mismatch";
		},

		startRequest: function( element ) {
			if ( !this.pending[ element.name ] ) {
				this.pendingRequest++;
				$( element ).addClass( this.settings.pendingClass );
				this.pending[ element.name ] = true;
			}
		},

		stopRequest: function( element, valid ) {
			this.pendingRequest--;

			// Sometimes synchronization fails, make sure pendingRequest is never < 0
			if ( this.pendingRequest < 0 ) {
				this.pendingRequest = 0;
			}
			delete this.pending[ element.name ];
			$( element ).removeClass( this.settings.pendingClass );
			if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {
				$( this.currentForm ).submit();

				// Remove the hidden input that was used as a replacement for the
				// missing submit button. The hidden input is added by `handle()`
				// to ensure that the value of the used submit button is passed on
				// for scripted submits triggered by this method
				if ( this.submitButton ) {
					$( "input:hidden[name='" + this.submitButton.name + "']", this.currentForm ).remove();
				}

				this.formSubmitted = false;
			} else if ( !valid && this.pendingRequest === 0 && this.formSubmitted ) {
				$( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
				this.formSubmitted = false;
			}
		},

		previousValue: function( element, method ) {
			method = typeof method === "string" && method || "remote";

			return $.data( element, "previousValue" ) || $.data( element, "previousValue", {
				old: null,
				valid: true,
				message: this.defaultMessage( element, { method: method } )
			} );
		},

		// Cleans up all forms and elements, removes validator-specific events
		destroy: function() {
			this.resetForm();

			$( this.currentForm )
				.off( ".validate" )
				.removeData( "validator" )
				.find( ".validate-equalTo-blur" )
					.off( ".validate-equalTo" )
					.removeClass( "validate-equalTo-blur" )
				.find( ".validate-lessThan-blur" )
					.off( ".validate-lessThan" )
					.removeClass( "validate-lessThan-blur" )
				.find( ".validate-lessThanEqual-blur" )
					.off( ".validate-lessThanEqual" )
					.removeClass( "validate-lessThanEqual-blur" )
				.find( ".validate-greaterThanEqual-blur" )
					.off( ".validate-greaterThanEqual" )
					.removeClass( "validate-greaterThanEqual-blur" )
				.find( ".validate-greaterThan-blur" )
					.off( ".validate-greaterThan" )
					.removeClass( "validate-greaterThan-blur" );
		}

	},

	classRuleSettings: {
		required: { required: true },
		email: { email: true },
		url: { url: true },
		date: { date: true },
		dateISO: { dateISO: true },
		number: { number: true },
		digits: { digits: true },
		creditcard: { creditcard: true }
	},

	addClassRules: function( className, rules ) {
		if ( className.constructor === String ) {
			this.classRuleSettings[ className ] = rules;
		} else {
			$.extend( this.classRuleSettings, className );
		}
	},

	classRules: function( element ) {
		var rules = {},
			classes = $( element ).attr( "class" );

		if ( classes ) {
			$.each( classes.split( " " ), function() {
				if ( this in $.validator.classRuleSettings ) {
					$.extend( rules, $.validator.classRuleSettings[ this ] );
				}
			} );
		}
		return rules;
	},

	normalizeAttributeRule: function( rules, type, method, value ) {

		// Convert the value to a number for number inputs, and for text for backwards compability
		// allows type="date" and others to be compared as strings
		if ( /min|max|step/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {
			value = Number( value );

			// Support Opera Mini, which returns NaN for undefined minlength
			if ( isNaN( value ) ) {
				value = undefined;
			}
		}

		if ( value || value === 0 ) {
			rules[ method ] = value;
		} else if ( type === method && type !== "range" ) {

			// Exception: the jquery validate 'range' method
			// does not test for the html5 'range' type
			rules[ method ] = true;
		}
	},

	attributeRules: function( element ) {
		var rules = {},
			$element = $( element ),
			type = element.getAttribute( "type" ),
			method, value;

		for ( method in $.validator.methods ) {

			// Support for <input required> in both html5 and older browsers
			if ( method === "required" ) {
				value = element.getAttribute( method );

				// Some browsers return an empty string for the required attribute
				// and non-HTML5 browsers might have required="" markup
				if ( value === "" ) {
					value = true;
				}

				// Force non-HTML5 browsers to return bool
				value = !!value;
			} else {
				value = $element.attr( method );
			}

			this.normalizeAttributeRule( rules, type, method, value );
		}

		// 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs
		if ( rules.maxlength && /-1|2147483647|524288/.test( rules.maxlength ) ) {
			delete rules.maxlength;
		}

		return rules;
	},

	dataRules: function( element ) {
		var rules = {},
			$element = $( element ),
			type = element.getAttribute( "type" ),
			method, value;

		for ( method in $.validator.methods ) {
			value = $element.data( "rule" + method.charAt( 0 ).toUpperCase() + method.substring( 1 ).toLowerCase() );

			// Cast empty attributes like `data-rule-required` to `true`
			if ( value === "" ) {
				value = true;
			}

			this.normalizeAttributeRule( rules, type, method, value );
		}
		return rules;
	},

	staticRules: function( element ) {
		var rules = {},
			validator = $.data( element.form, "validator" );

		if ( validator.settings.rules ) {
			rules = $.validator.normalizeRule( validator.settings.rules[ element.name ] ) || {};
		}
		return rules;
	},

	normalizeRules: function( rules, element ) {

		// Handle dependency check
		$.each( rules, function( prop, val ) {

			// Ignore rule when param is explicitly false, eg. required:false
			if ( val === false ) {
				delete rules[ prop ];
				return;
			}
			if ( val.param || val.depends ) {
				var keepRule = true;
				switch ( typeof val.depends ) {
				case "string":
					keepRule = !!$( val.depends, element.form ).length;
					break;
				case "function":
					keepRule = val.depends.call( element, element );
					break;
				}
				if ( keepRule ) {
					rules[ prop ] = val.param !== undefined ? val.param : true;
				} else {
					$.data( element.form, "validator" ).resetElements( $( element ) );
					delete rules[ prop ];
				}
			}
		} );

		// Evaluate parameters
		$.each( rules, function( rule, parameter ) {
			rules[ rule ] = $.isFunction( parameter ) && rule !== "normalizer" ? parameter( element ) : parameter;
		} );

		// Clean number parameters
		$.each( [ "minlength", "maxlength" ], function() {
			if ( rules[ this ] ) {
				rules[ this ] = Number( rules[ this ] );
			}
		} );
		$.each( [ "rangelength", "range" ], function() {
			var parts;
			if ( rules[ this ] ) {
				if ( $.isArray( rules[ this ] ) ) {
					rules[ this ] = [ Number( rules[ this ][ 0 ] ), Number( rules[ this ][ 1 ] ) ];
				} else if ( typeof rules[ this ] === "string" ) {
					parts = rules[ this ].replace( /[\[\]]/g, "" ).split( /[\s,]+/ );
					rules[ this ] = [ Number( parts[ 0 ] ), Number( parts[ 1 ] ) ];
				}
			}
		} );

		if ( $.validator.autoCreateRanges ) {

			// Auto-create ranges
			if ( rules.min != null && rules.max != null ) {
				rules.range = [ rules.min, rules.max ];
				delete rules.min;
				delete rules.max;
			}
			if ( rules.minlength != null && rules.maxlength != null ) {
				rules.rangelength = [ rules.minlength, rules.maxlength ];
				delete rules.minlength;
				delete rules.maxlength;
			}
		}

		return rules;
	},

	// Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
	normalizeRule: function( data ) {
		if ( typeof data === "string" ) {
			var transformed = {};
			$.each( data.split( /\s/ ), function() {
				transformed[ this ] = true;
			} );
			data = transformed;
		}
		return data;
	},

	// https://jqueryvalidation.org/jQuery.validator.addMethod/
	addMethod: function( name, method, message ) {
		$.validator.methods[ name ] = method;
		$.validator.messages[ name ] = message !== undefined ? message : $.validator.messages[ name ];
		if ( method.length < 3 ) {
			$.validator.addClassRules( name, $.validator.normalizeRule( name ) );
		}
	},

	// https://jqueryvalidation.org/jQuery.validator.methods/
	methods: {

		// https://jqueryvalidation.org/required-method/
		required: function( value, element, param ) {

			// Check if dependency is met
			if ( !this.depend( param, element ) ) {
				return "dependency-mismatch";
			}
			if ( element.nodeName.toLowerCase() === "select" ) {

				// Could be an array for select-multiple or a string, both are fine this way
				var val = $( element ).val();
				return val && val.length > 0;
			}
			if ( this.checkable( element ) ) {
				return this.getLength( value, element ) > 0;
			}
			return value !== undefined && value !== null && value.length > 0;
		},

		// https://jqueryvalidation.org/email-method/
		email: function( value, element ) {

			// From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address
			// Retrieved 2014-01-14
			// If you have a problem with this implementation, report a bug against the above spec
			// Or use custom methods to implement your own email validation
			return this.optional( element ) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test( value );
		},

		// https://jqueryvalidation.org/url-method/
		url: function( value, element ) {

			// Copyright (c) 2010-2013 Diego Perini, MIT licensed
			// https://gist.github.com/dperini/729294
			// see also https://mathiasbynens.be/demo/url-regex
			// modified to allow protocol-relative URLs
			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
		},

		// https://jqueryvalidation.org/date-method/
		date: ( function() {
			var called = false;

			return function( value, element ) {
				if ( !called ) {
					called = true;
					if ( this.settings.debug && window.console ) {
						console.warn(
							"The `date` method is deprecated and will be removed in version '2.0.0'.\n" +
							"Please don't use it, since it relies on the Date constructor, which\n" +
							"behaves very differently across browsers and locales. Use `dateISO`\n" +
							"instead or one of the locale specific methods in `localizations/`\n" +
							"and `additional-methods.js`."
						);
					}
				}

				return this.optional( element ) || !/Invalid|NaN/.test( new Date( value ).toString() );
			};
		}() ),

		// https://jqueryvalidation.org/dateISO-method/
		dateISO: function( value, element ) {
			return this.optional( element ) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test( value );
		},

		// https://jqueryvalidation.org/number-method/
		number: function( value, element ) {
			return this.optional( element ) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test( value );
		},

		// https://jqueryvalidation.org/digits-method/
		digits: function( value, element ) {
			return this.optional( element ) || /^\d+$/.test( value );
		},

		// https://jqueryvalidation.org/minlength-method/
		minlength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || length >= param;
		},

		// https://jqueryvalidation.org/maxlength-method/
		maxlength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || length <= param;
		},

		// https://jqueryvalidation.org/rangelength-method/
		rangelength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || ( length >= param[ 0 ] && length <= param[ 1 ] );
		},

		// https://jqueryvalidation.org/min-method/
		min: function( value, element, param ) {
			return this.optional( element ) || value >= param;
		},

		// https://jqueryvalidation.org/max-method/
		max: function( value, element, param ) {
			return this.optional( element ) || value <= param;
		},

		// https://jqueryvalidation.org/range-method/
		range: function( value, element, param ) {
			return this.optional( element ) || ( value >= param[ 0 ] && value <= param[ 1 ] );
		},

		// https://jqueryvalidation.org/step-method/
		step: function( value, element, param ) {
			var type = $( element ).attr( "type" ),
				errorMessage = "Step attribute on input type " + type + " is not supported.",
				supportedTypes = [ "text", "number", "range" ],
				re = new RegExp( "\\b" + type + "\\b" ),
				notSupported = type && !re.test( supportedTypes.join() ),
				decimalPlaces = function( num ) {
					var match = ( "" + num ).match( /(?:\.(\d+))?$/ );
					if ( !match ) {
						return 0;
					}

					// Number of digits right of decimal point.
					return match[ 1 ] ? match[ 1 ].length : 0;
				},
				toInt = function( num ) {
					return Math.round( num * Math.pow( 10, decimals ) );
				},
				valid = true,
				decimals;

			// Works only for text, number and range input types
			// TODO find a way to support input types date, datetime, datetime-local, month, time and week
			if ( notSupported ) {
				throw new Error( errorMessage );
			}

			decimals = decimalPlaces( param );

			// Value can't have too many decimals
			if ( decimalPlaces( value ) > decimals || toInt( value ) % toInt( param ) !== 0 ) {
				valid = false;
			}

			return this.optional( element ) || valid;
		},

		// https://jqueryvalidation.org/equalTo-method/
		equalTo: function( value, element, param ) {

			// Bind to the blur event of the target in order to revalidate whenever the target field is updated
			var target = $( param );
			if ( this.settings.onfocusout && target.not( ".validate-equalTo-blur" ).length ) {
				target.addClass( "validate-equalTo-blur" ).on( "blur.validate-equalTo", function() {
					$( element ).valid();
				} );
			}
			return value === target.val();
		},

		// https://jqueryvalidation.org/remote-method/
		remote: function( value, element, param, method ) {
			if ( this.optional( element ) ) {
				return "dependency-mismatch";
			}

			method = typeof method === "string" && method || "remote";

			var previous = this.previousValue( element, method ),
				validator, data, optionDataString;

			if ( !this.settings.messages[ element.name ] ) {
				this.settings.messages[ element.name ] = {};
			}
			previous.originalMessage = previous.originalMessage || this.settings.messages[ element.name ][ method ];
			this.settings.messages[ element.name ][ method ] = previous.message;

			param = typeof param === "string" && { url: param } || param;
			optionDataString = $.param( $.extend( { data: value }, param.data ) );
			if ( previous.old === optionDataString ) {
				return previous.valid;
			}

			previous.old = optionDataString;
			validator = this;
			this.startRequest( element );
			data = {};
			data[ element.name ] = value;
			$.ajax( $.extend( true, {
				mode: "abort",
				port: "validate" + element.name,
				dataType: "json",
				data: data,
				context: validator.currentForm,
				success: function( response ) {
					var valid = response === true || response === "true",
						errors, message, submitted;

					validator.settings.messages[ element.name ][ method ] = previous.originalMessage;
					if ( valid ) {
						submitted = validator.formSubmitted;
						validator.resetInternals();
						validator.toHide = validator.errorsFor( element );
						validator.formSubmitted = submitted;
						validator.successList.push( element );
						validator.invalid[ element.name ] = false;
						validator.showErrors();
					} else {
						errors = {};
						message = response || validator.defaultMessage( element, { method: method, parameters: value } );
						errors[ element.name ] = previous.message = message;
						validator.invalid[ element.name ] = true;
						validator.showErrors( errors );
					}
					previous.valid = valid;
					validator.stopRequest( element, valid );
				}
			}, param ) );
			return "pending";
		}
	}

} );

// Ajax mode: abort
// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()

var pendingRequests = {},
	ajax;

// Use a prefilter if available (1.5+)
if ( $.ajaxPrefilter ) {
	$.ajaxPrefilter( function( settings, _, xhr ) {
		var port = settings.port;
		if ( settings.mode === "abort" ) {
			if ( pendingRequests[ port ] ) {
				pendingRequests[ port ].abort();
			}
			pendingRequests[ port ] = xhr;
		}
	} );
} else {

	// Proxy ajax
	ajax = $.ajax;
	$.ajax = function( settings ) {
		var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
			port = ( "port" in settings ? settings : $.ajaxSettings ).port;
		if ( mode === "abort" ) {
			if ( pendingRequests[ port ] ) {
				pendingRequests[ port ].abort();
			}
			pendingRequests[ port ] = ajax.apply( this, arguments );
			return pendingRequests[ port ];
		}
		return ajax.apply( this, arguments );
	};
}
return $;
}));